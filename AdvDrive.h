//------------------------------------------------------------------------------------
//  Управление приводом с концевиками подключенным по 2-x релейной схеме. 
//  Контролирует время движения до концевика и перегрузку по току 
//------------------------------------------------------------------------------------
#pragma once
#include <Arduino.h>

enum driveDir {   //Направление движения
  DRIVE_DIR_BACKWARD = 0,
  DRIVE_DIR_FORWARD
};

enum driveEndSw {   //Состояние концевиков 
  DRIVE_SW_PUSHED = 0,
  DRIVE_SW_REALIZED
};

enum driveMoveStatus {  //Текущее состояние привода
  DRIVE_STATUS_OK = 0,
  DRIVE_STATUS_OVERTIME,
  DRIVE_STATUS_OVERLOAD,
  DRIVE_STATUS_IN_WORK = 10
};

class AdvDrive
{
public:
  //------------------------------------------------------------------------------------
  //                  Конструктор
  //------------------------------------------------------------------------------------
  AdvDrive  (uint32_t pinFrw,        uint32_t pinBkw = NC,       //Пины назад и вперед
            uint32_t pinSwFrw = NC,  uint32_t pinSwBkw = NC,     //Пин переднего и заднего концевика 
            bool swLevelFrw = HIGH,  bool swLevelBkw = HIGH)     //Уровень концевиков в НЕ сработаном состоянии (0 или 1)
  {
    //Сохраняем пины
    pin_frw = pinFrw;           
    pin_bkw = pinBkw;
    pinSw_frw = pinSwFrw;
    pinSw_bkw = pinSwBkw;
    //Сохраняем нормальный уровень концевиков
    swLev_frw = swLevelFrw;
    swLev_bkw = swLevelBkw;
    //Настройка портов
    pinMode(pin_frw, OUTPUT);   //Пин переднего направления
    if (pin_bkw != NC)    pinMode(pin_bkw, OUTPUT); 
    if (pinSw_frw != NC)  pinMode(pinSw_frw, INPUT_PULLUP);
    if (pinSw_bkw != NC)  pinMode(pinSw_bkw, INPUT_PULLUP);
  }
  ~AdvDrive () {}

  //------------------------------------------------------------------------------------
  //          Установить макс. ток и макс. время перегрузки до отключения
  //------------------------------------------------------------------------------------
  void setOverload ( float *pCurr, float maxCurr, uint32_t maxTimeSec = 1) {
    pcurr = pCurr;
    overloadCurr = maxCurr;
    overloadTime = maxTimeSec;
  }

  //------------------------------------------------------------------------------------
  //          Установить макс. время работы мотора до достижения концевика
  //------------------------------------------------------------------------------------
  void setTime ( uint32_t maxTimeSec ) {
    workTime = maxTimeSec;
  }

  //------------------------------------------------------------------------------------
  //          Установить направление: 0 - назад, 1 - вперед
  //------------------------------------------------------------------------------------
  void setDir ( bool direction ) {
    dir = direction;
  }

  //------------------------------------------------------------------------------------
  //                  Отключить мотор
  //------------------------------------------------------------------------------------
  void motorOff (void)
  {
    digitalWrite(pin_frw, LOW);
    if (pin_bkw != NC) digitalWrite(pin_bkw, LOW);
  }

  //------------------------------------------------------------------------------------
  //                  Включаем мотор
  //------------------------------------------------------------------------------------
  void motorOn (bool dir = 0)
  {
    motorOff(); //Предванительно отключить все
    if (dir)                  digitalWrite(pin_frw, HIGH);    // Вперед
    else if (pin_bkw != NC)   digitalWrite(pin_bkw, HIGH);
  }

  //----------------------------------------------------------------------------
  //  Считать состояние концевика. 
  //  Принимает концевик: 1 - передний, 0 - задний
  //  Возвращает: 1 - концевик сработан, 0 - не сработан
  //----------------------------------------------------------------------------
  bool readEndSw( bool dir = 1 )
  {
    bool sw;
    switch (dir) {
      case DRIVE_DIR_FORWARD:
        if (pinSw_frw != NC) {
          sw = digitalRead(pinSw_frw); 
          if (swLev_frw == HIGH)   sw = !sw;   //Если разомкнутый концевик дает 1, то инверсия, иначе прямое считывание
          return sw;
        }
        return 0;
        
      case DRIVE_DIR_BACKWARD: 
        if (pinSw_bkw != NC) {
          sw = digitalRead(pinSw_bkw); 
          if (swLev_bkw == HIGH)   sw = !sw;   
          return sw;
        }
        return 0;
    }
  }
  
  //----------------------------------------------------------------------------
  //  Прочитать статус движения привода. 
  //  Возвращает: 0 - успешное завершение, 
  //              1 - превышено время,
  //              2 - перегрузка по току,
  //              10 - в движении 
  //----------------------------------------------------------------------------
  int getStatus() {
    return moveStatus;
  }

  //----------------------------------------------------------------------------
  //  Контроль пререгрузки по току, вызывается в цикле
  //  Принимает: текущее значение тока
  //  Возвращает: 0 - нет перегрузки, 1 - перегрузка более указанного времени 
  //---------------------------------------------------------------------------- 
  int overloadControl() {
    if (pcurr == 0) return 0;  //Если не установлено

    //Контроль перегрузки
    switch ( f_overCurr ) 
    {
      case 0:			//Режим без перегрузки 
        if ( *pcurr > overloadCurr ) {     //Проверка  есть ли перегрузка
          tmrOverload = millis(); //Запуск таймера
          f_overCurr = 1;	//Зафиксирована перегрузка
        }
        return 0;
      
      case 1:			//Режим перегрузки 
        if (*pcurr <= overloadCurr) {
          f_overCurr = 0;  //Убрать перегрузку если ток упал 
          return 0;
        }
        if ( millis() - tmrOverload > overloadTime * 1000 ) { //Перегрузка более заданного времени
          f_overCurr = 0;	//Убрать перегрузку
          return 1;						
        }
        return 0;
    }
  }

  //------------------------------------------------------------------------------------------------
  //  Запуск движения. Вызывается в цикле, результат выполнения отслеживается через getStatus()
  //  Возвращает: см. getStatus()
  //------------------------------------------------------------------------------------------------
  void run()  {
    switch (state)  //Состояние
    {
      //---------Инициализация------------
      case 0: //Начало работы
        moveStatus = DRIVE_STATUS_IN_WORK; //Статус - в процессе выполнения
        motorOn(dir); //Включаем  мотор
        tmrStart = millis(); // Фиксируем время запуска
        state = 1;  //Далее
      
      //-----------Работа----------
      case 1:
        //Проверка пришла ли дверь в положение
        if (readEndSw(dir)) {
          moveStatus = DRIVE_STATUS_OK;		      //ОК
          break;
        }    
        //проверка времени работы, если задано
        if ( workTime  &&  millis() - tmrStart > workTime * 1000 ) {
          moveStatus = DRIVE_STATUS_OVERTIME;     //Превышено время
          break;						
        }
        //Проверка перегрузки
        if ( overloadControl() ) {
          moveStatus = DRIVE_STATUS_OVERLOAD;		      //Перегрузка по току
          break; 
        }
        return;
    }
    //Отключение
    motorOff();			        //Выключить мотор
    state = 0;              //в начало
  }

  //----------------------------------------------------------------------------
  //  Запуск движения, блокирующая функция (можно использовать при многозадачности)
  //  Принимает направление: 0 - впред, 1 - назад; время работы (0 - игнорировать)
  //  Возвращает: см. getStatus()
  //---------------------------------------------------------------------------- 
  int move(bool dir, int maxTimeSec = 0) {
    setDir(dir);
    if (maxTimeSec) setTime(maxTimeSec);  //Если задано время работы, установить его
    moveStatus = DRIVE_STATUS_IN_WORK;    //Статус выставить в процессе выполнения
    while (getStatus() == DRIVE_STATUS_IN_WORK) //Пока не завершилась работа
      run();      //Запускаем в цикле 
    return getStatus();
  }

  //----------------------------------------------------------------------------
  //  Запуск движения, блокирующая функция, без аргументов (задаются предварительно)
  //---------------------------------------------------------------------------- 
  int move() {
    return move(dir, workTime);
  }

private:
  uint32_t pin_frw, pin_bkw;         //Пины включения 
  uint32_t pinSw_frw, pinSw_bkw;     //Пины концевиков 
  bool swLev_frw, swLev_bkw;        //Уровень с концевиков в не сработаном состоянии (0 или 1)
  float overloadCurr = 0;           //Максимальный порог тока
  int overloadTime = 0;             //Максималное время перегрузки
  float *pcurr = 0;                 //Указатель на переменную с текущим значением тока
  
  int workTime = 0;
  int moveStatus = 0;
  bool dir = 1;
  int state = 0; 
  bool f_overCurr = 0;
  uint32_t tmrStart;
  uint32_t tmrOverload;
};
